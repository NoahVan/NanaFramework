redis:
首先redis是一个基于内存的nosql中间件，有五种数据结构，支持持久化，常用来做缓存，分布式锁等，相比于同类产品memcache，提供了持久化，
更多的数据类型，并且是单线程的
1、最常用的 String 他的存储结构是动态字符串，可以修改，采用预分配冗余空间的方式来减少内存的频繁分配，他这是典型的空间换时间的思想
（内部为当前字符串分配内存时，实际分配的空间会高于字符串的实际长度，当字符串的大小小于1M时，扩容都是加倍现有空间，
如果超过1M,每次扩容1M,字符串最大是512M）
因为他是动态字符串结构，我猜测他的扩容规则，应该类似于ArrayList,会新创建分配一块扩容后的内存，然后将数据拷贝到新分配的内存中
2、是他的List类型 他的存储结构是双向链表，我们都知道，链表这种结构首尾插入和删除操作的时间复杂度都是O(1),但他随机定位能力较弱
时间复杂度比较高是O(n)
3、hash类型 他的数据结构类似于java中的HashMap，数组+链表的方式，hash的内容key和value存放在链表中，数组中存放的是链表的头指针，
存储时，他首先会利用hash函数来计算key的hashCode，然后用hashcode对数组长度取模，然后定位到链表的表头，再对链表进行遍历获取相应的
value,链表结构是为了处理hash碰撞的情况的，当hash碰撞发生的比较频繁时，他会扩容，数组会扩容为原来的两倍，将所有的键值对重新分配，
如果键值对过多，一次完整的搬移操作会耗时过长，所以它采用了一种渐进式的方式，他首先会同时保留新旧两个hash结构，在后续的定时任务，
以及hash结构的读写指令中将旧的结构中的数据逐渐地移过去
4、set类型 他的内部也是hash结构的，所有的value都指向同一个内部值
5、zset类型 底层使用了两种数据结构，第一个是hash，第二个是跳跃表，hash的作用就是存储value和权重score，保障元素value的唯一性，
可以通过元素value找到相应的score值，而跳跃表的作用是为了给元素排序

备份和持久化 Redis支持RDB和AOF两种持久化机制,持久化功能有效的避免因进程退出造成的数据丢失问题，RDB是每隔一段时间生成redis内存中的数据的
一份完整的快照，AOF方式是有数据写入redis,redis自身就会先将数据写入aof日志文件（会先写入os cache），过大的话会利用缓存淘汰算法，
删除旧的数据

---------------------------------------------------------------------------------------------------------------------------------
dubbo ：
是一个分布式服务框架，提供RPC远程服务调用
它基于接口方法的远程过程调用，基于注册中心目录服务，使服务的消费方能动态的查找服务提供方，
服务提供方可以平滑增加或减少机器。

在大规模服务化之前，应用可能只是通过 RMI 或 Hessian 等工具，简单的暴露和引用远程服务，
通过配置服务的URL地址进行调用，通过 F5 等硬件进行负载均衡，当服务越来越多的时候，
url地址的配置管理变得困难，F5硬件的负载均衡器的单点压力越来越大，而此时就迫切的需要
一个服务注册中心，能够动态的注册和发现服务，并通过在消费方获取服务提供方地址列表，
实现软负载均衡和 Failover，以及随着服务量的增大，需要提供多少台服务器支撑，什么时候加
服务器，为了解决这个问题，我们可以通过监控中心把每天的调用量，响应时间都统计出来，作为参考指标
我们还可以给一台机器一直加权重，并记录响应时间的变化，直到响应时间达到阈值，记录此时的访问量，
我们就可以乘以机器数反推总容量了，这样就可以根据需求添加服务器了

他的整体架构包括服务提供方，注册中心，服务消费方，监控中心，以及Container服务运行容器
服务提供者在启动时，向注册中心注册自己提供的服务
服务消费方在启动时，向注册中心订阅自己所需要的服务
注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者
服务消费者，基于软负载均衡算法，从提供者列表里选一台提供者进行调用，如果调用失败，再选另一台调用
---------------------------------------------------------------------------------------------------------------------------------


classLoader：
类加载器，装载class字节码文件，java程序启动的时候，需要装载类到jvm中，但它不是一次性的都装载进去，他会先加载一些基础类，
其他类等到jvm需要用到时再装载，这样的好处是节省了内存的开销

在JVM中就算是同一个类，如果是由不同加载器加载的，他会认为这是不同的类，这样的话就乱套了
所以即便在Java中提供了Bootstrp loader（是由c++实现的），ExtClassLoader，AppClassLoader加载器，
但他们分别负责加载不同区域的类，利用一种双亲委派机制，类加载器在加载类时会先询问parent，让parent帮助加载，
如果parent不能加载，他才会去加载类，这样就保证了一个类由一个类加载器加载

（可以触发类加载的有：new，class.forname()，调用静态变量，静态方法）
---------------------------------------------------------------------------------------------------------------------------------

集合
    List
    ArrayList 内部数据结构是数组，是线程不安全的，扩容规则是oldCapacity + (oldCapacity >> 1)，扩容为原来的1.5倍
    Vector 内部数据结构是数组，方法上都是同步的，加有synchronized，扩容规则是有一个capacityIncrement如果大于0，就扩容这些，
 否则扩容为原来的两倍
    LinkedList 内部数据结构是双向链表，设有头尾节点，线程不安全
    CopyOnWriteArrayList 内部使用volatile数组结构，保证内存可见性，他在进行操作时会先将当前数组复制一份，
 在新数组上操作，然后再赋值给它，来保证线程安全，但是会导致数据弱一致性
    CopyOnWriteArraySet 里面操作的就是CopyOnWriteArrayList
    Set
    HashSet 是利用HashMap实现的，利用了HashMap的key来存储数据，他是使用散列函数计算位置的，所以他的位置是随机的，
 所以不能保证顺序
    TreeSet 是使用TreeMap实现，利用红黑树的先序遍历保证顺序
    LinkedHashSet 是利用linkedHashMap实现的
    Map
    Hashtable 默认大小是11，加载因子是0.75，采用数组加链表的方式存储，使用同步机制方法保证线程安全，不支持null键和值
    HashMap 默认大小是16，加载因子是0.75，采用数组加链表的方式存储，线程不安全
    LinkedHashMap 继承HashMap，默认大小，加载因子同HashMap，数据结构是数组加双向链表，双向链表维护了元素插入的先后顺序
    ConcurrentHashMap 使用volatile+cas算法来保证线程安全的
    Collections 中提供有同步方法，使用装饰器模式对原有集合方法进行同步操作
---------------------------------------------------------------------------------------------------------------------------------

多线程
它的安全性，为什么存在线程不安全
   1、我们都知道系统进行资源的分配和调度是以进程为单位进行分配的，而线程是进程的一个实体，
   而进程中堆和方法区的资源是线程间共享的，但cpu又是以线程为单位采用轮片的方式进行分配，
   当存在多个线程同时操作共享资源时，就可能会出现不安全的问题
   针对这种情况，我们可以给资源加锁，来保证在某一时刻，当前资源只被一个线程持有，直到当前线程释放
   2、线程的安全一般可以计算依赖严格的执行顺序，这个在多线程里又无法保证的
   3、或者计算值依赖某个变量，多核cpu中cahce行缓存等原因，其他线程修改了变量，但是没有同步，就会出现问题
   针对这两种情况我们可以使用volatile和cas算法，或者加锁来保证线程安全

提到这里就让我想到了Java中java concurrent package(java并发工具包下)提供的一些保证线程安全的工具类
 CopyOnWriteArrayList 内部使用volatile数组结构，保证内存可见性，他在进行操作时会先将当前数组复制一份，
 在新数组上操作，然后再赋值给它，来保证线程安全，但是会导致数据弱一致性
 CopyOnWriteArraySet 里面操作的就是CopyOnWriteArrayList
 ConcurrentHashMap 中使用到了volatile，cas，synchronized来





---------------------------------------------------------------------------------------------------------------------------------

1、1+2
2、3 + 6
3、9 + 18
4、27 +